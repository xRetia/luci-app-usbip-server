#!/bin/sh /etc/rc.common

START=99
STOP=10

USE_PROCD=1
NAME=usbip_monitor
DAEMON=/usr/bin/usbip_monitor.sh
PIDFILE=/var/run/usbip_monitor.pid

start_service() {
    # Disable the original usbipd service to avoid conflicts
    if [ -f /etc/init.d/usbipd ]; then
        /etc/init.d/usbipd disable 2>/dev/null
        /etc/init.d/usbipd stop 2>/dev/null
    fi
    
    procd_open_instance
    procd_set_param command "$DAEMON"
    procd_set_param respawn
    procd_set_param respawn_retry 5
    procd_set_param stdout 1
    procd_set_param stderr 1
    procd_set_param pidfile "$PIDFILE"
    procd_close_instance
}

stop_service() {
    # Stop our monitor and usbipd server with timeout protection
    local timeout=5
    
    # Try to kill processes with TERM signal first
    killall -f "usbip_monitor.sh" 2>/dev/null
    killall -f "usbipd" 2>/dev/null
    
    # Wait for processes to terminate with timeout
    local count=0
    while [ $count -lt $timeout ]; do
        if ! pgrep -f "usbip_monitor.sh" >/dev/null && ! pgrep -f "usbipd" >/dev/null; then
            break
        fi
        count=$((count + 1))
        sleep 1
    done
    
    # If processes still running after timeout, use killall as fallback
    if pgrep -f "usbip_monitor.sh" >/dev/null || pgrep -f "usbipd" >/dev/null; then
        killall -9 usbip_monitor.sh 2>/dev/null
        killall -9 usbipd 2>/dev/null
    fi
}

restart() {
    stop
    start
}

service_triggers() {
    procd_add_reload_trigger usbip_server
}